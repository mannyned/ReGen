// Prisma Schema for ReGenr - Universal Social Media Integration
// Database: PostgreSQL (production) / SQLite (development)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION (Supabase Auth Integration)
// ============================================

// Profile table - linked to Supabase auth.users
// This is the primary user entity for application data.
// The id is a UUID that matches auth.users.id from Supabase.
//
// Supabase manages authentication (auth.users table).
// We manage application-level user data (profiles table).

model Profile {
  id          String   @id @db.Uuid  // UUID from Supabase auth.users.id
  email       String   @unique
  displayName String?  @map("display_name")
  avatarUrl   String?  @map("avatar_url")
  tier        UserTier @default(FREE)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Beta Pro Access (temporary Pro access for beta testers)
  betaUser      Boolean   @default(false) @map("beta_user")
  betaExpiresAt DateTime? @map("beta_expires_at")

  // Stripe subscription fields
  stripeCustomerId       String?   @unique @map("stripe_customer_id")
  stripeSubscriptionId   String?   @unique @map("stripe_subscription_id")
  stripeSubscriptionStatus SubscriptionStatus? @map("stripe_subscription_status")
  stripePriceId          String?   @map("stripe_price_id")
  stripeCurrentPeriodEnd DateTime? @map("stripe_current_period_end")

  // Relations - Profile is the main entity for all user data
  socialConnections  SocialConnection[]
  oauthConnections   OAuthConnection[]
  contentUploads     ContentUpload[]
  scheduledPosts     ScheduledPost[]
  analyticsSnapshots AnalyticsSnapshot[]
  exportJobs         ExportJob[]

  // Team relations
  ownedTeam       Team?        @relation("TeamOwner")
  teamMembership  TeamMember?
  sentTeamInvites TeamInvite[]

  @@index([stripeCustomerId])
  @@index([betaUser])
  @@map("profiles")
}

// User tier/subscription levels
enum UserTier {
  FREE
  CREATOR
  PRO

  @@map("user_tier")
}

// Stripe subscription status (mirrors Stripe's subscription statuses)
enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  TRIALING
  INCOMPLETE
  INCOMPLETE_EXPIRED

  @@map("subscription_status")
}

// ============================================
// LEGACY USER MODEL (Deprecated - Migrate to Profile)
// ============================================
// Keeping for backward compatibility during migration.
// New code should use Profile with Supabase Auth.

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  passwordHash  String?
  emailVerified DateTime?
  image         String?
  plan          PlanTier  @default(FREE)
  planExpiresAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations (legacy)
  sessions      Session[]
  refreshTokens RefreshToken[]
}

// Legacy session model (Supabase handles sessions now)
model Session {
  id           String   @id @default(cuid())
  userId       String
  token        String   @unique
  expiresAt    DateTime
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Legacy refresh token model (Supabase handles tokens now)
model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Legacy plan tier enum (use UserTier for new code)
enum PlanTier {
  FREE
  CREATOR
  PRO
}

// ============================================
// SOCIAL MEDIA CONNECTIONS
// ============================================

model SocialConnection {
  id              String         @id @default(cuid())
  profileId       String         @map("profile_id") @db.Uuid
  platform        SocialPlatform
  platformUserId  String         @map("platform_user_id")
  username        String?
  displayName     String?        @map("display_name")
  profileImageUrl String?        @map("profile_image_url")

  // OAuth Tokens (encrypted at rest)
  accessToken     String         @map("access_token")
  refreshToken    String?        @map("refresh_token")
  tokenExpiresAt  DateTime?      @map("token_expires_at")
  scopes          String[]

  // Platform-specific metadata
  metadata        Json?

  // Status
  isActive        Boolean  @default(true) @map("is_active")
  lastSyncAt      DateTime? @map("last_sync_at")
  lastErrorAt     DateTime? @map("last_error_at")
  lastError       String?   @map("last_error")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  publishedPosts PublishedPost[]
  analyticsSnapshots AnalyticsSnapshot[]

  @@unique([profileId, platform])
  @@index([platform])
  @@index([profileId])
  @@map("social_connections")
}

enum SocialPlatform {
  INSTAGRAM
  TIKTOK
  YOUTUBE
  TWITTER
  LINKEDIN
  FACEBOOK
  SNAPCHAT
}

// ============================================
// UNIVERSAL OAUTH CONNECTIONS
// ============================================

// New OAuth connection model for the universal OAuth engine
// Uses string provider field for flexibility with new platforms
// Tokens are AES-256-GCM encrypted at rest

model OAuthConnection {
  id                String    @id @default(cuid())
  profileId         String    @map("profile_id") @db.Uuid
  provider          String    // Provider ID: 'meta', 'tiktok', 'google', 'x', 'linkedin'
  providerAccountId String    @map("provider_account_id")

  // Encrypted OAuth tokens (AES-256-GCM)
  accessTokenEnc    String    @map("access_token_enc")
  refreshTokenEnc   String?   @map("refresh_token_enc")

  // Token metadata
  scopes            String[]
  expiresAt         DateTime? @map("expires_at")

  // Provider-specific data (pages, channels, business accounts, etc.)
  metadata          Json?     @default("{}")

  // Timestamps
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // Relations
  profile           Profile   @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Constraints
  @@unique([profileId, provider])
  @@index([provider])
  @@index([profileId])
  @@index([expiresAt])
  @@map("oauth_connections")
}

// ============================================
// CONTENT MANAGEMENT
// ============================================

model ContentUpload {
  id           String      @id @default(cuid())
  profileId    String      @map("profile_id") @db.Uuid

  // Original content
  originalUrl  String      @map("original_url")
  fileName     String      @map("file_name")
  fileSize     Int         @map("file_size")
  mimeType     String      @map("mime_type")
  duration     Int?        // For videos, in seconds

  // Processed versions
  thumbnailUrl  String?    @map("thumbnail_url")
  processedUrls Json?      @map("processed_urls")

  // AI-generated content
  generatedCaptions Json?  @map("generated_captions")
  brandVoiceProfile String? @map("brand_voice_profile")

  status       ContentStatus @default(PROCESSING)
  createdAt    DateTime     @default(now()) @map("created_at")
  updatedAt    DateTime     @updatedAt @map("updated_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  scheduledPosts ScheduledPost[]
  publishedPosts PublishedPost[]

  @@index([profileId])
  @@index([status])
  @@map("content_uploads")
}

enum ContentStatus {
  PROCESSING
  READY
  FAILED
  ARCHIVED
}

// ============================================
// SCHEDULING & PUBLISHING
// ============================================

model ScheduledPost {
  id              String         @id @default(cuid())
  profileId       String         @map("profile_id") @db.Uuid
  contentUploadId String         @map("content_upload_id")

  // Publishing details
  platforms       SocialPlatform[]
  scheduledAt     DateTime       @map("scheduled_at")
  timezone        String         @default("UTC")

  // Content for each platform
  platformContent Json           @map("platform_content")

  status          ScheduleStatus @default(PENDING)
  processedAt     DateTime?      @map("processed_at")
  errorMessage    String?        @map("error_message")

  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  contentUpload ContentUpload @relation(fields: [contentUploadId], references: [id])
  publishedPosts PublishedPost[]

  @@index([profileId])
  @@index([scheduledAt])
  @@index([status])
  @@map("scheduled_posts")
}

enum ScheduleStatus {
  PENDING
  PROCESSING
  COMPLETED
  PARTIAL_FAILURE
  FAILED
  CANCELLED
}

model PublishedPost {
  id                 String          @id @default(cuid())
  scheduledPostId    String?
  contentUploadId    String
  socialConnectionId String

  // Platform response
  platform           SocialPlatform
  platformPostId     String?
  platformUrl        String?

  // Content published
  caption            String?
  hashtags           String[]

  status             PublishStatus   @default(PENDING)
  errorMessage       String?
  publishedAt        DateTime?

  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt

  scheduledPost   ScheduledPost?   @relation(fields: [scheduledPostId], references: [id])
  contentUpload   ContentUpload    @relation(fields: [contentUploadId], references: [id])
  socialConnection SocialConnection @relation(fields: [socialConnectionId], references: [id])
  analyticsData   PostAnalytics?

  @@index([platform])
  @@index([publishedAt])
}

enum PublishStatus {
  PENDING
  PROCESSING
  PUBLISHED
  FAILED
  DELETED
}

// ============================================
// ANALYTICS
// ============================================

model PostAnalytics {
  id              String   @id @default(cuid())
  publishedPostId String   @unique

  // Engagement metrics
  views           Int      @default(0)
  likes           Int      @default(0)
  comments        Int      @default(0)
  shares          Int      @default(0)
  saves           Int      @default(0)

  // Video-specific metrics
  avgWatchTime    Float?   // In seconds
  completionRate  Float?   // Percentage 0-100

  // Reach metrics
  reach           Int      @default(0)
  impressions     Int      @default(0)

  // Audience demographics (JSON for flexibility)
  demographics    Json?
  locationData    Json?

  // Retention data for videos
  retentionCurve  Json?    // [{ timestamp: number, retention: number }]

  lastSyncAt      DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  publishedPost PublishedPost @relation(fields: [publishedPostId], references: [id], onDelete: Cascade)
}

model AnalyticsSnapshot {
  id                 String          @id @default(cuid())
  profileId          String          @map("profile_id") @db.Uuid
  socialConnectionId String          @map("social_connection_id")
  platform           SocialPlatform

  // Account-level metrics
  followers          Int             @default(0)
  following          Int             @default(0)
  totalPosts         Int             @default(0) @map("total_posts")

  // Engagement metrics (aggregated)
  avgEngagementRate  Float?          @map("avg_engagement_rate")
  avgReach           Int?            @map("avg_reach")
  avgImpressions     Int?            @map("avg_impressions")

  // Period metrics
  periodStart        DateTime        @map("period_start")
  periodEnd          DateTime        @map("period_end")

  // Detailed breakdown
  metricsBreakdown   Json?           @map("metrics_breakdown")

  createdAt          DateTime        @default(now()) @map("created_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  socialConnection SocialConnection @relation(fields: [socialConnectionId], references: [id])

  @@index([profileId, platform])
  @@index([periodStart, periodEnd])
  @@map("analytics_snapshots")
}

// ============================================
// RATE LIMITING & API USAGE
// ============================================

model ApiRateLimit {
  id           String         @id @default(cuid())
  platform     SocialPlatform
  endpoint     String

  // Rate limit configuration
  maxRequests  Int
  windowMs     Int            // Time window in milliseconds

  // Current usage
  currentCount Int            @default(0)
  windowStart  DateTime       @default(now())

  @@unique([platform, endpoint])
}

model WebhookEvent {
  id           String         @id @default(cuid())
  platform     SocialPlatform
  eventType    String
  payload      Json
  processedAt  DateTime?
  error        String?
  createdAt    DateTime       @default(now())

  @@index([platform, eventType])
  @@index([processedAt])
}

// ============================================
// ANALYTICS EXPORT (PRO FEATURE)
// ============================================

model ExportJob {
  id            String       @id @default(cuid())
  profileId     String       @map("profile_id") @db.Uuid

  // Export configuration
  format        ExportFormat
  options       Json         // ExportOptions including filters

  // Job status
  status        ExportStatus @default(PENDING)
  progress      Int          @default(0)
  error         String?

  // Output file details
  fileName      String?      @map("file_name")
  fileSize      Int?         @map("file_size")
  fileUrl       String?      @map("file_url")

  // Audit information
  rowCount      Int?         @map("row_count")
  platforms     SocialPlatform[]
  dateRangeFrom DateTime?    @map("date_range_from")
  dateRangeTo   DateTime?    @map("date_range_to")

  // Timestamps
  createdAt     DateTime     @default(now()) @map("created_at")
  completedAt   DateTime?    @map("completed_at")
  expiresAt     DateTime?    @map("expires_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  auditLogs ExportAuditLog[]

  @@index([profileId])
  @@index([status])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("export_jobs")
}

model ExportAuditLog {
  id           String   @id @default(cuid())
  exportJobId  String   @map("export_job_id")
  profileId    String   @map("profile_id") @db.Uuid

  // Audit details
  action       String   // 'created', 'downloaded', 'expired', 'deleted'
  ipAddress    String?  @map("ip_address")
  userAgent    String?  @map("user_agent")

  createdAt    DateTime @default(now()) @map("created_at")

  exportJob ExportJob @relation(fields: [exportJobId], references: [id], onDelete: Cascade)

  @@index([profileId])
  @@index([exportJobId])
  @@index([createdAt])
  @@map("export_audit_logs")
}

enum ExportFormat {
  CSV
  PDF
}

enum ExportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// ============================================
// NOTIFICATION TRACKING
// ============================================

model NotificationLog {
  id          String           @id @default(cuid())
  profileId   String           @map("profile_id") @db.Uuid
  type        NotificationType
  channel     NotificationChannel @default(EMAIL)
  recipient   String           // Email address or phone number
  subject     String?
  metadata    Json?            // Additional context (subscriptionId, interval, etc.)
  sentAt      DateTime         @default(now()) @map("sent_at")
  createdAt   DateTime         @default(now()) @map("created_at")

  @@index([profileId])
  @@index([type])
  @@index([sentAt])
  @@map("notification_logs")
}

enum NotificationType {
  SUBSCRIPTION_WELCOME
  SUBSCRIPTION_RENEWED
  SUBSCRIPTION_CANCELLED
  SUBSCRIPTION_REACTIVATED
  SUBSCRIPTION_EXPIRING
  PAYMENT_FAILED
  PAYMENT_SUCCEEDED
  WELCOME
  PASSWORD_RESET
  EMAIL_VERIFICATION

  @@map("notification_type")
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH

  @@map("notification_channel")
}

// ============================================
// WAITLIST
// ============================================

model WaitlistEntry {
  id        String   @id @default(cuid())
  email     String   @unique
  source    String?  // Where they signed up from (landing, pricing, etc.)
  createdAt DateTime @default(now()) @map("created_at")

  @@index([createdAt])
  @@map("waitlist_entries")
}

// ============================================
// BETA INVITES (Pre-registration)
// ============================================

/// Beta invite for users who haven't signed up yet.
/// When they sign up, they automatically get PRO tier with beta expiration.
model BetaInvite {
  id           String    @id @default(cuid())
  email        String    @unique
  durationDays Int       @default(30) @map("duration_days")
  createdAt    DateTime  @default(now()) @map("created_at")
  usedAt       DateTime? @map("used_at")  // When the user signed up and claimed the invite
  expiresAt    DateTime? @map("expires_at")  // When the invite itself expires (optional)

  @@index([email])
  @@index([createdAt])
  @@map("beta_invites")
}

// ============================================
// TEAM MANAGEMENT (PRO FEATURE)
// ============================================

/// Team role enum for role-based access control
enum TeamRole {
  OWNER
  ADMIN
  MEMBER

  @@map("team_role")
}

/// Team - A workspace owned by a PRO user that can have multiple members
/// Owner is the PRO subscriber who pays for the team
model Team {
  id        String   @id @default(cuid())
  name      String   @default("My Team")
  ownerId   String   @unique @map("owner_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  owner   Profile      @relation("TeamOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members TeamMember[]
  invites TeamInvite[]

  @@index([ownerId])
  @@map("teams")
}

/// TeamMember - Links a user to a team with a specific role
/// Users can only be a member of one team at a time
model TeamMember {
  id       String   @id @default(cuid())
  teamId   String   @map("team_id")
  userId   String   @unique @map("user_id") @db.Uuid
  role     TeamRole @default(MEMBER)
  joinedAt DateTime @default(now()) @map("joined_at")

  // Relations
  team Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user Profile @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
  @@map("team_members")
}

/// TeamInvite - Pending invitation to join a team
/// Expires after 7 days if not accepted
model TeamInvite {
  id          String   @id @default(cuid())
  teamId      String   @map("team_id")
  email       String
  role        TeamRole @default(MEMBER)
  invitedById String   @map("invited_by_id") @db.Uuid
  token       String   @unique @default(cuid())
  expiresAt   DateTime @map("expires_at")
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  team      Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedBy Profile @relation(fields: [invitedById], references: [id], onDelete: Cascade)

  @@unique([teamId, email])
  @@index([teamId])
  @@index([email])
  @@index([token])
  @@index([expiresAt])
  @@map("team_invites")
}
