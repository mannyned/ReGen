// Prisma Schema for ReGenr - Universal Social Media Integration
// Database: PostgreSQL (production) / SQLite (development)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================
// USER & AUTHENTICATION (Supabase Auth Integration)
// ============================================

// Profile table - linked to Supabase auth.users
// This is the primary user entity for application data.
// The id is a UUID that matches auth.users.id from Supabase.
//
// Supabase manages authentication (auth.users table).
// We manage application-level user data (profiles table).

model Profile {
  id          String   @id @db.Uuid // UUID from Supabase auth.users.id
  email       String   @unique
  displayName String?  @map("display_name")
  avatarUrl   String?  @map("avatar_url")
  tier        UserTier @default(FREE)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Beta Pro Access (temporary Pro access for beta testers)
  betaUser      Boolean   @default(false) @map("beta_user")
  betaExpiresAt DateTime? @map("beta_expires_at")

  // Workspace limits (PRO feature)
  workspaceLimit Int @default(1) @map("workspace_limit")

  // Stripe subscription fields
  stripeCustomerId         String?             @unique @map("stripe_customer_id")
  stripeSubscriptionId     String?             @unique @map("stripe_subscription_id")
  stripeSubscriptionStatus SubscriptionStatus? @map("stripe_subscription_status")
  stripePriceId            String?             @map("stripe_price_id")
  stripeCurrentPeriodEnd   DateTime?           @map("stripe_current_period_end")

  // User preferences
  notificationPreferences Json? @map("notification_preferences")
  pushSubscription        Json? @map("push_subscription") // Web Push subscription for PWA notifications

  // Relations - Profile is the main entity for all user data
  socialConnections  SocialConnection[]
  oauthConnections   OAuthConnection[]
  contentUploads     ContentUpload[]
  scheduledPosts     ScheduledPost[]
  analyticsSnapshots AnalyticsSnapshot[]
  exportJobs         ExportJob[]

  // Team/Workspace relations
  ownedTeam       Team?        @relation("TeamOwner")
  teamMemberships TeamMember[] // Users can be members of multiple workspaces
  sentTeamInvites TeamInvite[]

  // RSS Feed relations
  rssFeeds     RssFeed[]
  rssFeedItems RssFeedItem[]

  // TikTok relations
  tiktokPosts        TikTokPost[]
  tiktokVideoMetrics TikTokVideoMetrics[]

  // Cross-platform outbound posts
  outboundPosts OutboundPost[]

  // YouTube metrics cache
  youtubeMetrics YouTubeMetricsCache[]

  // Blog Auto-Share
  blogAutoShareSettings BlogAutoShareSettings?
  blogAutoSharePosts    BlogAutoSharePost[]

  // Beta Feedback tracking
  hasCompletedFirstPost      Boolean        @default(false) @map("has_completed_first_post")
  hasViewedAnalyticsFirst    Boolean        @default(false) @map("has_viewed_analytics_first")
  hasCompletedFirstAutoShare Boolean        @default(false) @map("has_completed_first_auto_share")
  feedbackDismissedTypes     String[]       @default([]) @map("feedback_dismissed_types")
  lastFeedbackPromptAt       DateTime?      @map("last_feedback_prompt_at")
  betaFeedback               BetaFeedback[]

  // User-provided API credentials (BYOK - Bring Your Own Keys)
  apiCredentials UserApiCredentials[]

  @@index([stripeCustomerId])
  @@index([betaUser])
  @@map("profiles")
}

// User tier/subscription levels
enum UserTier {
  FREE
  CREATOR
  PRO

  @@map("user_tier")
}

// Stripe subscription status (mirrors Stripe's subscription statuses)
enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  TRIALING
  INCOMPLETE
  INCOMPLETE_EXPIRED

  @@map("subscription_status")
}

// ============================================
// LEGACY USER MODEL (Deprecated - Migrate to Profile)
// ============================================
// Keeping for backward compatibility during migration.
// New code should use Profile with Supabase Auth.

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  passwordHash  String?
  emailVerified DateTime?
  image         String?
  plan          PlanTier  @default(FREE)
  planExpiresAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations (legacy)
  sessions      Session[]
  refreshTokens RefreshToken[]
}

// Legacy session model (Supabase handles sessions now)
model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Legacy refresh token model (Supabase handles tokens now)
model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Legacy plan tier enum (use UserTier for new code)
enum PlanTier {
  FREE
  CREATOR
  PRO
}

// ============================================
// SOCIAL MEDIA CONNECTIONS
// ============================================

model SocialConnection {
  id              String         @id @default(cuid())
  profileId       String         @map("profile_id") @db.Uuid
  workspaceId     String?        @map("workspace_id") // Nullable for backwards compatibility
  platform        SocialPlatform
  platformUserId  String         @map("platform_user_id")
  username        String?
  displayName     String?        @map("display_name")
  profileImageUrl String?        @map("profile_image_url")

  // OAuth Tokens (encrypted at rest)
  accessToken    String    @map("access_token")
  refreshToken   String?   @map("refresh_token")
  tokenExpiresAt DateTime? @map("token_expires_at")
  scopes         String[]

  // Platform-specific metadata
  metadata Json?

  // Status
  isActive    Boolean   @default(true) @map("is_active")
  lastSyncAt  DateTime? @map("last_sync_at")
  lastErrorAt DateTime? @map("last_error_at")
  lastError   String?   @map("last_error")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  profile            Profile             @relation(fields: [profileId], references: [id], onDelete: Cascade)
  workspace          Team?               @relation(fields: [workspaceId], references: [id])
  publishedPosts     PublishedPost[]
  analyticsSnapshots AnalyticsSnapshot[]

  @@unique([profileId, platform])
  @@index([platform])
  @@index([profileId])
  @@index([workspaceId])
  @@map("social_connections")
}

enum SocialPlatform {
  INSTAGRAM
  TIKTOK
  YOUTUBE
  TWITTER
  LINKEDIN
  FACEBOOK
  META
  SNAPCHAT
  PINTEREST
  DISCORD
  REDDIT
}

// ============================================
// UNIVERSAL OAUTH CONNECTIONS
// ============================================

// New OAuth connection model for the universal OAuth engine
// Uses string provider field for flexibility with new platforms
// Tokens are AES-256-GCM encrypted at rest

model OAuthConnection {
  id                String  @id @default(cuid())
  profileId         String  @map("profile_id") @db.Uuid
  workspaceId       String? @map("workspace_id") // Nullable for backwards compatibility
  provider          String // Provider ID: 'meta', 'tiktok', 'google', 'x', 'linkedin'
  providerAccountId String  @map("provider_account_id")

  // Encrypted OAuth tokens (AES-256-GCM)
  accessTokenEnc  String  @map("access_token_enc")
  refreshTokenEnc String? @map("refresh_token_enc")

  // Token metadata
  scopes    String[]
  expiresAt DateTime? @map("expires_at")

  // Provider-specific data (pages, channels, business accounts, etc.)
  metadata Json? @default("{}")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  workspace Team?   @relation(fields: [workspaceId], references: [id])

  // Constraints
  @@unique([profileId, provider])
  @@index([provider])
  @@index([profileId])
  @@index([workspaceId])
  @@index([expiresAt])
  @@map("oauth_connections")
}

// OAuth State - Temporary storage for OAuth state during authorization flow
// Used for providers where cookies don't work reliably (e.g., Discord with webhook.incoming)
model OAuthState {
  id             String   @id @default(cuid())
  state          String   @unique // The state parameter value
  provider       String // Provider ID
  profileId      String   @map("profile_id") @db.Uuid
  codeVerifier   String?  @map("code_verifier") // For PKCE flows
  targetPlatform String?  @map("target_platform") // For Meta's Instagram/Facebook targeting
  expiresAt      DateTime @map("expires_at")
  createdAt      DateTime @default(now()) @map("created_at")

  @@index([state])
  @@index([expiresAt])
  @@map("oauth_states")
}

// ============================================
// CONTENT MANAGEMENT
// ============================================

model ContentUpload {
  id          String  @id @default(cuid())
  profileId   String  @map("profile_id") @db.Uuid
  workspaceId String? @map("workspace_id") // Nullable for backwards compatibility

  // Original content
  originalUrl String @map("original_url")
  fileName    String @map("file_name")
  fileSize    Int    @map("file_size")
  mimeType    String @map("mime_type")
  duration    Int? // For videos, in seconds

  // Processed versions
  thumbnailUrl  String? @map("thumbnail_url")
  processedUrls Json?   @map("processed_urls")

  // AI-generated content
  generatedCaptions Json?   @map("generated_captions")
  brandVoiceProfile String? @map("brand_voice_profile")

  status    ContentStatus @default(PROCESSING)
  createdAt DateTime      @default(now()) @map("created_at")
  updatedAt DateTime      @updatedAt @map("updated_at")

  profile        Profile         @relation(fields: [profileId], references: [id], onDelete: Cascade)
  workspace      Team?           @relation(fields: [workspaceId], references: [id])
  scheduledPosts ScheduledPost[]
  publishedPosts PublishedPost[]
  rssFeedItems   RssFeedItem[]
  tiktokPosts    TikTokPost[]
  outboundPosts  OutboundPost[]

  @@index([profileId])
  @@index([workspaceId])
  @@index([status])
  @@map("content_uploads")
}

enum ContentStatus {
  PROCESSING
  READY
  FAILED
  ARCHIVED
}

// ============================================
// SCHEDULING & PUBLISHING
// ============================================

model ScheduledPost {
  id              String  @id @default(cuid())
  profileId       String  @map("profile_id") @db.Uuid
  workspaceId     String? @map("workspace_id") // Nullable for backwards compatibility
  contentUploadId String  @map("content_upload_id")

  // Publishing details
  platforms   SocialPlatform[]
  scheduledAt DateTime         @map("scheduled_at")
  timezone    String           @default("UTC")

  // Content for each platform
  platformContent Json @map("platform_content")

  status       ScheduleStatus @default(PENDING)
  processedAt  DateTime?      @map("processed_at")
  errorMessage String?        @map("error_message")

  // Repeat/Repost grouping (for "Repeat for X days" feature)
  repeatGroupId String? @map("repeat_group_id")
  repeatIndex   Int?    @map("repeat_index")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  profile        Profile         @relation(fields: [profileId], references: [id], onDelete: Cascade)
  workspace      Team?           @relation(fields: [workspaceId], references: [id])
  contentUpload  ContentUpload   @relation(fields: [contentUploadId], references: [id])
  publishedPosts PublishedPost[]

  @@index([profileId])
  @@index([workspaceId])
  @@index([scheduledAt])
  @@index([status])
  @@index([repeatGroupId])
  @@map("scheduled_posts")
}

enum ScheduleStatus {
  PENDING
  PROCESSING
  COMPLETED
  PARTIAL_FAILURE
  FAILED
  CANCELLED
}

model PublishedPost {
  id                 String  @id @default(cuid())
  scheduledPostId    String?
  contentUploadId    String
  socialConnectionId String

  // Platform response
  platform       SocialPlatform
  platformPostId String?
  platformUrl    String?

  // Content published
  caption  String?
  hashtags String[]

  status       PublishStatus @default(PENDING)
  errorMessage String?
  publishedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  scheduledPost    ScheduledPost?   @relation(fields: [scheduledPostId], references: [id])
  contentUpload    ContentUpload    @relation(fields: [contentUploadId], references: [id])
  socialConnection SocialConnection @relation(fields: [socialConnectionId], references: [id])
  analyticsData    PostAnalytics?

  @@index([platform])
  @@index([publishedAt])
}

enum PublishStatus {
  PENDING
  PROCESSING
  PUBLISHED
  FAILED
  DELETED
}

// ============================================
// ANALYTICS
// ============================================

model PostAnalytics {
  id              String @id @default(cuid())
  publishedPostId String @unique

  // Engagement metrics
  views    Int @default(0)
  likes    Int @default(0)
  comments Int @default(0)
  shares   Int @default(0)
  saves    Int @default(0)

  // Video-specific metrics
  avgWatchTime   Float? // In seconds
  completionRate Float? // Percentage 0-100

  // Reach metrics
  reach       Int @default(0)
  impressions Int @default(0)

  // Audience demographics (JSON for flexibility)
  demographics Json?
  locationData Json?

  // Retention data for videos
  retentionCurve Json? // [{ timestamp: number, retention: number }]

  lastSyncAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  publishedPost PublishedPost @relation(fields: [publishedPostId], references: [id], onDelete: Cascade)
}

model AnalyticsSnapshot {
  id                 String         @id @default(cuid())
  profileId          String         @map("profile_id") @db.Uuid
  workspaceId        String?        @map("workspace_id") // Nullable for backwards compatibility
  socialConnectionId String         @map("social_connection_id")
  platform           SocialPlatform

  // Account-level metrics
  followers  Int @default(0)
  following  Int @default(0)
  totalPosts Int @default(0) @map("total_posts")

  // Engagement metrics (aggregated)
  avgEngagementRate Float? @map("avg_engagement_rate")
  avgReach          Int?   @map("avg_reach")
  avgImpressions    Int?   @map("avg_impressions")

  // Period metrics
  periodStart DateTime @map("period_start")
  periodEnd   DateTime @map("period_end")

  // Detailed breakdown
  metricsBreakdown Json? @map("metrics_breakdown")

  createdAt DateTime @default(now()) @map("created_at")

  profile          Profile          @relation(fields: [profileId], references: [id], onDelete: Cascade)
  workspace        Team?            @relation(fields: [workspaceId], references: [id])
  socialConnection SocialConnection @relation(fields: [socialConnectionId], references: [id])

  @@index([profileId, platform])
  @@index([workspaceId])
  @@index([periodStart, periodEnd])
  @@map("analytics_snapshots")
}

// ============================================
// RATE LIMITING & API USAGE
// ============================================

model ApiRateLimit {
  id       String         @id @default(cuid())
  platform SocialPlatform
  endpoint String

  // Rate limit configuration
  maxRequests Int
  windowMs    Int // Time window in milliseconds

  // Current usage
  currentCount Int      @default(0)
  windowStart  DateTime @default(now())

  @@unique([platform, endpoint])
}

model WebhookEvent {
  id          String         @id @default(cuid())
  platform    SocialPlatform
  eventType   String
  payload     Json
  processedAt DateTime?
  error       String?
  createdAt   DateTime       @default(now())

  @@index([platform, eventType])
  @@index([processedAt])
}

// ============================================
// ANALYTICS EXPORT (PRO FEATURE)
// ============================================

model ExportJob {
  id          String  @id @default(cuid())
  profileId   String  @map("profile_id") @db.Uuid
  workspaceId String? @map("workspace_id") // Nullable for backwards compatibility

  // Export configuration
  format  ExportFormat
  options Json // ExportOptions including filters

  // Job status
  status   ExportStatus @default(PENDING)
  progress Int          @default(0)
  error    String?

  // Output file details
  fileName String? @map("file_name")
  fileSize Int?    @map("file_size")
  fileUrl  String? @map("file_url")

  // Audit information
  rowCount      Int?             @map("row_count")
  platforms     SocialPlatform[]
  dateRangeFrom DateTime?        @map("date_range_from")
  dateRangeTo   DateTime?        @map("date_range_to")

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  completedAt DateTime? @map("completed_at")
  expiresAt   DateTime? @map("expires_at")

  profile   Profile          @relation(fields: [profileId], references: [id], onDelete: Cascade)
  workspace Team?            @relation(fields: [workspaceId], references: [id])
  auditLogs ExportAuditLog[]

  @@index([profileId])
  @@index([workspaceId])
  @@index([status])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("export_jobs")
}

model ExportAuditLog {
  id          String @id @default(cuid())
  exportJobId String @map("export_job_id")
  profileId   String @map("profile_id") @db.Uuid

  // Audit details
  action    String // 'created', 'downloaded', 'expired', 'deleted'
  ipAddress String? @map("ip_address")
  userAgent String? @map("user_agent")

  createdAt DateTime @default(now()) @map("created_at")

  exportJob ExportJob @relation(fields: [exportJobId], references: [id], onDelete: Cascade)

  @@index([profileId])
  @@index([exportJobId])
  @@index([createdAt])
  @@map("export_audit_logs")
}

enum ExportFormat {
  CSV
  PDF
}

enum ExportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// ============================================
// NOTIFICATION TRACKING
// ============================================

model NotificationLog {
  id        String              @id @default(cuid())
  profileId String              @map("profile_id") @db.Uuid
  type      NotificationType
  channel   NotificationChannel @default(EMAIL)
  recipient String // Email address or phone number
  subject   String?
  metadata  Json? // Additional context (subscriptionId, interval, etc.)
  sentAt    DateTime            @default(now()) @map("sent_at")
  createdAt DateTime            @default(now()) @map("created_at")

  @@index([profileId])
  @@index([type])
  @@index([sentAt])
  @@map("notification_logs")
}

enum NotificationType {
  SUBSCRIPTION_WELCOME
  SUBSCRIPTION_RENEWED
  SUBSCRIPTION_CANCELLED
  SUBSCRIPTION_REACTIVATED
  SUBSCRIPTION_EXPIRING
  PAYMENT_FAILED
  PAYMENT_SUCCEEDED
  WELCOME
  PASSWORD_RESET
  EMAIL_VERIFICATION
  SCHEDULED_POST_PUBLISHED
  SCHEDULED_POST_FAILED

  @@map("notification_type")
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH

  @@map("notification_channel")
}

// ============================================
// WAITLIST
// ============================================

model WaitlistEntry {
  id        String   @id @default(cuid())
  email     String   @unique
  source    String? // Where they signed up from (landing, pricing, etc.)
  createdAt DateTime @default(now()) @map("created_at")

  @@index([createdAt])
  @@map("waitlist_entries")
}

// ============================================
// EMAIL VERIFICATION CODES
// ============================================

/// VerificationCode - Stores email verification codes for signup
/// Used instead of in-memory storage for serverless compatibility
model VerificationCode {
  id        String   @id @default(cuid())
  email     String   @unique
  code      String
  attempts  Int      @default(0)
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([email])
  @@index([expiresAt])
  @@map("verification_codes")
}

// ============================================
// BETA INVITES (Pre-registration)
// ============================================

/// Beta invite for users who haven't signed up yet.
/// When they sign up, they automatically get PRO tier with beta expiration.
model BetaInvite {
  id           String    @id @default(cuid())
  email        String    @unique
  durationDays Int       @default(30) @map("duration_days")
  createdAt    DateTime  @default(now()) @map("created_at")
  usedAt       DateTime? @map("used_at") // When the user signed up and claimed the invite
  expiresAt    DateTime? @map("expires_at") // When the invite itself expires (optional)

  @@index([email])
  @@index([createdAt])
  @@map("beta_invites")
}

// ============================================
// TEAM MANAGEMENT (PRO FEATURE)
// ============================================

/// Team role enum for role-based access control
enum TeamRole {
  OWNER
  ADMIN
  MEMBER

  @@map("team_role")
}

/// Team - A workspace owned by a PRO user that can have multiple members
/// Owner is the PRO subscriber who pays for the team
/// NOTE: Team serves as the Workspace entity for workspace-scoped features
model Team {
  id        String   @id @default(cuid())
  name      String   @default("My Workspace")
  ownerId   String   @unique @map("owner_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Workspace-specific fields
  isDefault Boolean @default(false) @map("is_default") // User's default workspace
  settings  Json?   @default("{}") // Workspace settings JSON

  // Analytics permissions (workspace-level toggle)
  // When true, team members can view account-level analytics
  // When false (default), members can only view content-level analytics
  allowMemberAccountAnalytics Boolean @default(false) @map("allow_member_account_analytics")

  // Relations
  owner   Profile      @relation("TeamOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members TeamMember[]
  invites TeamInvite[]

  // Workspace-scoped content relations
  socialConnections     SocialConnection[]
  oauthConnections      OAuthConnection[]
  contentUploads        ContentUpload[]
  scheduledPosts        ScheduledPost[]
  analyticsSnapshots    AnalyticsSnapshot[]
  exportJobs            ExportJob[]
  rssFeeds              RssFeed[]
  outboundPosts         OutboundPost[]
  blogAutoShareSettings BlogAutoShareSettings[]

  @@index([ownerId])
  @@index([isDefault])
  @@map("teams")
}

/// TeamMember - Links a user to a team/workspace with a specific role
/// Users can be members of multiple workspaces (workspace-scoped permissions)
model TeamMember {
  id       String   @id @default(cuid())
  teamId   String   @map("team_id")
  userId   String   @map("user_id") @db.Uuid // Removed @unique - users can be in multiple workspaces
  role     TeamRole @default(MEMBER)
  joinedAt DateTime @default(now()) @map("joined_at")

  // Admin permissions (granted by owner)
  // Only applicable when role is ADMIN
  canRename Boolean @default(false) @map("can_rename")

  // Relations
  team Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user Profile @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
  @@map("team_members")
}

/// TeamInvite - Pending invitation to join a team
/// Expires after 7 days if not accepted
model TeamInvite {
  id          String   @id @default(cuid())
  teamId      String   @map("team_id")
  email       String
  role        TeamRole @default(MEMBER)
  invitedById String   @map("invited_by_id") @db.Uuid
  token       String   @unique @default(cuid())
  expiresAt   DateTime @map("expires_at")
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  team      Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedBy Profile @relation(fields: [invitedById], references: [id], onDelete: Cascade)

  @@unique([teamId, email])
  @@index([teamId])
  @@index([email])
  @@index([token])
  @@index([expiresAt])
  @@map("team_invites")
}

// ============================================
// RSS FEED INGESTION
// ============================================

/// RSS Feed status for polling management
enum RssFeedStatus {
  ACTIVE
  PAUSED
  ERROR

  @@map("rss_feed_status")
}

/// RSS Item status for workflow tracking
enum RssItemStatus {
  NEW
  REVIEWED
  CONVERTED
  DISMISSED

  @@map("rss_item_status")
}

/// RssFeed - User's subscribed RSS feed URLs
/// Stores feed configuration and metadata for content ingestion
model RssFeed {
  id          String  @id @default(cuid())
  profileId   String  @map("profile_id") @db.Uuid
  workspaceId String? @map("workspace_id") // Nullable for backwards compatibility

  // Feed configuration
  name String
  url  String

  // Feed metadata (populated after first fetch)
  feedTitle       String? @map("feed_title")
  feedDescription String? @map("feed_description")
  feedImageUrl    String? @map("feed_image_url")
  feedLink        String? @map("feed_link")

  // Status and polling
  status        RssFeedStatus @default(ACTIVE)
  lastFetchedAt DateTime?     @map("last_fetched_at")
  lastError     String?       @map("last_error")
  errorCount    Int           @default(0) @map("error_count")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  profile   Profile       @relation(fields: [profileId], references: [id], onDelete: Cascade)
  workspace Team?         @relation(fields: [workspaceId], references: [id])
  items     RssFeedItem[]

  // Constraints
  @@unique([profileId, url])
  @@index([profileId])
  @@index([workspaceId])
  @@index([status])
  @@index([lastFetchedAt])
  @@map("rss_feeds")
}

/// RssFeedItem - Individual items ingested from RSS feeds
/// Represents content that can be converted to scheduled posts
model RssFeedItem {
  id        String @id @default(cuid())
  feedId    String @map("feed_id")
  profileId String @map("profile_id") @db.Uuid

  // Item content
  guid        String // Unique identifier from feed (RSS guid or link)
  title       String
  link        String?
  description String?
  content     String? // Full content if available
  author      String?
  imageUrl    String?   @map("image_url")
  publishedAt DateTime? @map("published_at")

  // Categories/tags from feed
  categories String[]

  // Processing status
  status RssItemStatus @default(NEW)

  // Reference to created content (if converted)
  contentUploadId String? @map("content_upload_id")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  feed               RssFeed             @relation(fields: [feedId], references: [id], onDelete: Cascade)
  profile            Profile             @relation(fields: [profileId], references: [id], onDelete: Cascade)
  contentUpload      ContentUpload?      @relation(fields: [contentUploadId], references: [id])
  blogAutoSharePosts BlogAutoSharePost[]

  // Constraints - prevent duplicate items per feed
  @@unique([feedId, guid])
  @@index([feedId])
  @@index([profileId])
  @@index([status])
  @@index([publishedAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("rss_feed_items")
}

// ============================================
// TIKTOK INTEGRATION
// ============================================

/// TikTok post status tracking
enum TikTokPostStatus {
  PENDING
  UPLOADING
  PROCESSING
  POSTED
  FAILED
  SCHEDULED

  @@map("tiktok_post_status")
}

/// TikTokPost - Track posts initiated via ReGenr to TikTok
/// Supports both immediate and scheduled posting
model TikTokPost {
  id              String  @id @default(cuid())
  profileId       String  @map("profile_id") @db.Uuid
  workspaceId     String? @map("workspace_id")
  contentUploadId String? @map("content_upload_id")

  // TikTok identifiers
  tiktokVideoId String? @map("tiktok_video_id")
  publishId     String? @map("publish_id")

  // Post status
  status      TikTokPostStatus @default(PENDING)
  scheduledAt DateTime?        @map("scheduled_at")
  postedAt    DateTime?        @map("posted_at")
  lastError   String?          @map("last_error")

  // Post content
  caption      String?
  privacyLevel String? @default("PUBLIC_TO_EVERYONE") @map("privacy_level")

  // TikTok post settings
  disableComment Boolean @default(false) @map("disable_comment")
  disableDuet    Boolean @default(false) @map("disable_duet")
  disableStitch  Boolean @default(false) @map("disable_stitch")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  profile       Profile        @relation(fields: [profileId], references: [id], onDelete: Cascade)
  contentUpload ContentUpload? @relation(fields: [contentUploadId], references: [id])

  @@index([profileId])
  @@index([status])
  @@index([scheduledAt])
  @@index([tiktokVideoId])
  @@map("tiktok_posts")
}

/// TikTokVideoMetrics - Cache metrics fetched from TikTok Display API
/// Stores historical metrics to avoid excessive API calls
model TikTokVideoMetrics {
  id            String @id @default(cuid())
  profileId     String @map("profile_id") @db.Uuid
  tiktokVideoId String @map("tiktok_video_id")

  // Timestamp when metrics were fetched
  fetchedAt DateTime @default(now()) @map("fetched_at")

  // Metrics data as JSON for flexibility
  // { views: number, likes: number, comments: number, shares: number }
  metrics Json

  // Relations
  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Unique per video per day to avoid duplicate entries
  @@unique([profileId, tiktokVideoId, fetchedAt])
  @@index([profileId])
  @@index([tiktokVideoId])
  @@index([fetchedAt])
  @@map("tiktok_video_metrics")
}

// ============================================
// OUTBOUND POSTS (Cross-Platform Posting Tracker)
// ============================================

/// Status for outbound posts across all platforms
enum OutboundPostStatus {
  QUEUED
  PROCESSING
  POSTED
  FAILED
  INITIATED // For user-initiated shares (Snapchat)
  DELETED // Post was deleted from the platform

  @@map("outbound_post_status")
}

/// OutboundPost - Track posts initiated via ReGenr across all platforms
/// Unified table for LinkedIn, YouTube, Snapchat, etc.
model OutboundPost {
  id              String  @id @default(cuid())
  profileId       String  @map("profile_id") @db.Uuid
  workspaceId     String? @map("workspace_id") // Nullable for backwards compatibility
  contentUploadId String? @map("content_upload_id")

  // Platform identifier
  provider String // 'linkedin', 'youtube', 'snapchat', etc.

  // External identifiers
  externalPostId String? @map("external_post_id") // Platform's post ID

  // Post status
  status      OutboundPostStatus @default(QUEUED)
  scheduledAt DateTime?          @map("scheduled_at")
  postedAt    DateTime?          @map("posted_at")
  lastError   String?            @map("last_error")

  // Metadata (platform-specific data as JSON)
  metadata Json @default("{}")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  profile       Profile        @relation(fields: [profileId], references: [id], onDelete: Cascade)
  workspace     Team?          @relation(fields: [workspaceId], references: [id])
  contentUpload ContentUpload? @relation(fields: [contentUploadId], references: [id])

  @@index([profileId])
  @@index([workspaceId])
  @@index([provider])
  @@index([status])
  @@index([scheduledAt])
  @@index([externalPostId])
  @@map("outbound_posts")
}

// ============================================
// YOUTUBE METRICS CACHE
// ============================================

/// YouTubeMetricsCache - Cache metrics fetched from YouTube Analytics API
/// Stores historical metrics to avoid excessive API calls
model YouTubeMetricsCache {
  id        String  @id @default(cuid())
  profileId String  @map("profile_id") @db.Uuid
  channelId String  @map("channel_id")
  videoId   String? @map("video_id") // null for channel-level metrics

  // Timestamp when metrics were fetched
  fetchedAt DateTime @default(now()) @map("fetched_at")

  // Metrics data as JSON for flexibility
  // { views, watchTime, likes, comments, shares, etc. }
  metrics Json

  // Relations
  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Unique per channel/video per day to avoid duplicate entries
  @@unique([profileId, channelId, videoId, fetchedAt])
  @@index([profileId])
  @@index([channelId])
  @@index([videoId])
  @@index([fetchedAt])
  @@map("youtube_metrics_cache")
}

// ============================================
// BLOG AUTO-SHARE AUTOMATION
// ============================================

/// BlogAutoShareSettings - User configuration for automatic blog post sharing
/// Stores preferences for RSS-to-social automation
model BlogAutoShareSettings {
  id          String  @id @default(cuid())
  profileId   String  @unique @map("profile_id") @db.Uuid
  workspaceId String? @map("workspace_id") // Nullable for backwards compatibility

  // Feature toggle
  enabled Boolean @default(false)

  // Blog URL (RSS feed URL for the user's blog)
  blogUrl String? @map("blog_url")

  // Platform selection (V1: instagram, facebook, twitter, linkedin, discord, pinterest)
  platforms String[] @default([])

  // Publishing mode
  autoPublish Boolean @default(false) @map("auto_publish") // false = create draft for approval

  // Default fallback image URL (used when og:image not found)
  defaultImageUrl String? @map("default_image_url")

  // Quiet hours (UTC) - don't publish during these hours
  quietHoursEnabled Boolean @default(false) @map("quiet_hours_enabled")
  quietHoursStart   Int?    @map("quiet_hours_start") // 0-23 hour
  quietHoursEnd     Int?    @map("quiet_hours_end") // 0-23 hour

  // Posting windows - preferred times (UTC)
  postingWindowEnabled Boolean @default(false) @map("posting_window_enabled")
  postingWindowStart   Int?    @map("posting_window_start") // 0-23 hour
  postingWindowEnd     Int?    @map("posting_window_end") // 0-23 hour

  // Per-platform caption templates (JSON object)
  // { "instagram": "Check out my new post! {title} {url}", "twitter": "{title} - Read more: {url}" }
  captionTemplates Json? @map("caption_templates")

  // RSS feed filter - only auto-share from specific feeds (null = all feeds)
  feedIds String[] @map("feed_ids")

  // Only share new posts - ignore items published before enabledAt
  onlyNewPosts Boolean   @default(true) @map("only_new_posts")
  enabledAt    DateTime? @map("enabled_at") // When auto-share was enabled (for filtering)

  // Discord channel for auto-share (if Discord is enabled)
  discordChannelId String? @map("discord_channel_id")

  // Pinterest board for auto-share (if Pinterest is enabled)
  pinterestBoardId String? @map("pinterest_board_id")

  // LinkedIn organization URN (if posting to company page)
  linkedinOrgUrn String? @map("linkedin_org_urn")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  workspace Team?   @relation(fields: [workspaceId], references: [id])

  @@index([profileId])
  @@index([workspaceId])
  @@index([enabled])
  @@map("blog_auto_share_settings")
}

/// BlogAutoSharePost status tracking
enum BlogAutoShareStatus {
  PENDING // Waiting to be processed
  DRAFT // Created as draft for user approval
  QUEUED // Approved, waiting for posting window
  PROCESSING // Currently being published
  PUBLISHED // Successfully published to all platforms
  PARTIAL // Published to some platforms, failed on others
  FAILED // Failed to publish to all platforms
  SKIPPED // Skipped (duplicate, quiet hours, etc.)

  @@map("blog_auto_share_status")
}

/// BlogAutoSharePost - Tracks individual blog post shares
/// Links RSS items to their cross-platform publishing results
model BlogAutoSharePost {
  id            String  @id @default(cuid())
  profileId     String  @map("profile_id") @db.Uuid
  rssFeedItemId String? @map("rss_feed_item_id") // Optional - not used when creating from blogUrl directly

  // Extracted metadata from article
  articleUrl     String  @map("article_url")
  canonicalUrl   String? @map("canonical_url")
  ogTitle        String? @map("og_title")
  ogDescription  String? @map("og_description")
  ogImage        String? @map("og_image")
  articleTitle   String  @map("article_title")
  articleExcerpt String? @map("article_excerpt")

  // Deduplication hash (SHA256 of guid + canonical URL)
  dedupeHash String @unique @map("dedupe_hash")

  // Generated caption (base caption before platform-specific modifications)
  generatedCaption String? @map("generated_caption")

  // Status
  status       BlogAutoShareStatus @default(PENDING)
  errorMessage String?             @map("error_message")

  // Scheduling
  scheduledAt DateTime? @map("scheduled_at")
  processedAt DateTime? @map("processed_at")

  // Platform results (JSON array)
  // [{ platform: "twitter", status: "published", postId: "123", postUrl: "...", error: null }]
  platformResults Json? @map("platform_results")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  profile     Profile      @relation(fields: [profileId], references: [id], onDelete: Cascade)
  rssFeedItem RssFeedItem? @relation(fields: [rssFeedItemId], references: [id], onDelete: Cascade)

  @@index([profileId])
  @@index([rssFeedItemId])
  @@index([status])
  @@index([scheduledAt])
  @@index([createdAt(sort: Desc)])
  @@map("blog_auto_share_posts")
}

// ============================================
// BETA FEEDBACK SYSTEM
// ============================================

/// Feedback type enum for categorizing beta feedback submissions
enum FeedbackType {
  FIRST_POST
  FIRST_ANALYTICS_VIEW
  FIRST_AUTO_SHARE
  GENERAL
  PRICING

  @@map("feedback_type")
}

/// BetaFeedback - Captures structured feedback from beta users
/// Triggered after meaningful events or via persistent "Give Feedback" option
model BetaFeedback {
  id        String @id @default(cuid())
  profileId String @map("profile_id") @db.Uuid

  // Feedback metadata
  feedbackType FeedbackType @map("feedback_type")

  // Structured feedback fields
  usageIntent        String? @map("usage_intent") // What they use ReGenr for
  featureValueRating Int?    @map("feature_value_rating") // 1-5 scale
  usefulnessRating   Int?    @map("usefulness_rating") // 1-5 scale
  confusionPoints    String? @map("confusion_points") // Open text - what's confusing
  missingFeatures    String? @map("missing_features") // Open text - feature requests

  // Pricing feedback (for PRICING type)
  creatorPriceInput            Decimal? @map("creator_price_input") @db.Decimal(10, 2)
  proPriceInput                Decimal? @map("pro_price_input") @db.Decimal(10, 2)
  additionalWorkspacePriceInput Decimal? @map("additional_workspace_price_input") @db.Decimal(10, 2)
  additionalSeatPriceInput     Decimal? @map("additional_seat_price_input") @db.Decimal(10, 2)
  pricingContext               Json?    @map("pricing_context") // { role, featuresUsed }

  // Additional context
  browserInfo     String? @map("browser_info")
  feedbackContext Json?   @map("feedback_context") // { page, action, timestamp }

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([profileId])
  @@index([feedbackType])
  @@index([createdAt(sort: Desc)])
  @@map("beta_feedback")
}

// ============================================
// USER API CREDENTIALS (BYOK - Bring Your Own Keys)
// ============================================

/// UserApiCredentials - Store user-provided API credentials for platforms
/// that require paid API access (e.g., Twitter/X)
/// All sensitive fields are AES-256-GCM encrypted
model UserApiCredentials {
  id        String @id @default(cuid())
  profileId String @map("profile_id") @db.Uuid
  provider  String // 'twitter', 'youtube', etc.

  // Encrypted credentials (AES-256-GCM)
  clientIdEnc     String @map("client_id_enc")
  clientSecretEnc String @map("client_secret_enc")

  // Optional: OAuth tokens if user provides pre-generated tokens
  accessTokenEnc  String? @map("access_token_enc")
  accessSecretEnc String? @map("access_secret_enc") // For OAuth 1.0a (Twitter v1)

  // Optional metadata
  appName String? @map("app_name") // User's app name for reference

  // Status
  isValid      Boolean   @default(true) @map("is_valid")
  lastError    String?   @map("last_error")
  lastTestedAt DateTime? @map("last_tested_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Constraints - one credential set per provider per user
  @@unique([profileId, provider])
  @@index([profileId])
  @@index([provider])
  @@map("user_api_credentials")
}
